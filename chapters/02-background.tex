\section{Background}
\label{sec:background}
%TODO: cite Gob homepage?
\gob\ is a static analyzer for C programs for detecting bugs and errors but also showing correctness. To prove certain properties about the program to be analyzed, it computes abstract states for each program point. These states describe all possible concrete state, the program can be in at that point in a sound manner. \gob\ finds the abstract states by solving a constraint system over the program points. This constraint system is generated from the \ac{cfg} according to the specifications of the type of analysis to be performed. The solution of the constraint system is a mapping from program points to abstract states, from which properties about bugs, errors and correctness can be deduced. \gob\ uses a fix-point solver to compute a satisfying solution.

  \subsection{Side-effecting constraint systems}
  \label{sec:background:constrSys}
  In this section we describe the constraint systems as they are generated and solved in \gob\ in more detail. The variables of the constraint system correspond to program points of the \ac{cfg}. If the program is analyzed context sensitively, each variable additionally has a context from an arbitrary context domain and thus, multiple variables can exist for the same program point with different contexts. This allows to analyze function calls from different calling contexts separately for increased precision. However, the additional context potentially makes the space of variables for the constraint system infinitely large as the context domain might be infinite. Even though this sounds bad at first, since a non-trivial solution to an infinite constraint system cannot be computed in finite time, this is not an issue. In the case of program analysis, the solution to the constraint system does not have to include a satisfying mapping to all variables, but only to those reachable from a set of one or more \textit{interesting} variables. In the case of program analysis in \gob\ this is usually the variable corresponding to the program point at the end of the main function.
  The value domain of the constraint system is a space of abstract states, that varies according to the specification of the analysis to be performed. In any case it has to be a complete lattice with a well-defined partial order, meet and join operations as well as a largest (top) and a least (bottom) value. Furthermore, to ensure termination of the constraint solver, widen and narrow operations are required.
  The constraint system now defines a constraint function for each variable. We refer to this function as the ``\ac{rhs}'' of a variable. The constraint system requires the variable to hold a value that is greater or equal to the value computed by the \ac{rhs} with respect to the partial order of the value lattice.
  The \ac{rhs} of a function can depend on other variables in the constraint system. We say, it \textit{queries} another variable for its value and uses that for its calculations.
  A peculiarity of the \gob\ analyzer is that it uses \textit{side-effecting} constraint systems. This means that some \ac{rhs} trigger \textit{side-effects} to other variables. When a side-effect is triggered, it posts a value to another variable in the constraint system, i.e., the variable that receives the side-effect has to hold a value, that is greater or equal to its previous value and the value received through the side effect. In \gob\ this is for example used for function calls to post the state from the caller to the variable at the start of the called function.
  For \gob\ it is ensured, that all variables that receive side-effects only have a trivial \ac{rhs}, i.e., one that is only a constant initial value.
  We note here, that with 
  % Leave out?
  We can think of the constraint system as a graph, where the program points are the nodes and the edges represent queries and side-effects from the \ac{rhs}, i.e., if the \ac{rhs} of variable $x$ queries variable $y$, we draw a \textit{query} edge from $x$ to $y$. Similarly, a side-effect from $x$ to $y$ results in an \textit{side-effect} edge from $x$ to $y$. The \textit{query} edges span a graph very similar to the \ac{cfg} with flipped edges, since the \ac{rhs} for a variable usually queries the variable corresponding to the program point before it and applies the abstract effect of the instruction between the two program points to the queried value.

  \subsection{Top-down solver}
  \label{sec:background:td}
  % TODO: cite "three improvements to top down solver" ?
  % TODO: somehow integrate notion of poi variables earlier
  \gob\ mainly employs \acp{td} to solve its constraint systems. The most optimized of these uses implements many improvements and additional features, including but not limited to solving with widening and narrowing phases and incremental analysis. 
  In this section we introduce a simplified version of this solver that is the basis for the parallelized solvers we introduce in~\autoref{sec:method:td_parallel}.
  The task of the solver is to compute a solution to the constraint system. Since the domain of the constraints is a complete lattice, this can be achieved through fix-point iteration. This means that all variables are assigned the bottom value of the lattice, after which the variables are repeatedly \textit{iterated} until a fix-point is reached. In each iteration of a variable, its \ac{rhs} is evaluated for a new value. If the new value is not the same as their current one, the variable is assigned a value greater than or equal to both the current and the new value. Once all variables have a that is at least as great as their \ac{rhs}, a fix-point is reached.
  Different solvers employ different strategies to decide which variable should be iterated next. Before explaining the strategy of the \ac{td} we introduce some important properties the solver tracks for the constraint variables:
  \begin{itemize}[leftmargin=*]
    \item \textbf{value:} The current value assigned to this variable from the value domain
    \item \textbf{called:} A called variable is currently in the stack of variables to be iterated.
    \item \textbf{stable:} A stable variable currently satisfies its constraints. This holds as long as none of the variables it depends on change their value.
    \item \textbf{influences:} A transitive relation between two variables $x$ and $y$. ``$x$ influences $y$'' means that the value of variable $y$ depends on the value of $x$, because the \ac{rhs} of $y$ \textit{queries} $x$.
    \item \textbf{wpoint:} If a variable is updated while it is a widening-point (wpoint), widening is applied when computing the new value. This is necessary to ensure termination of the solver.
  \end{itemize}

  \noindent The \ac{td} starts from one variable form the set of interesting variables, for which it is supposed to compute a value and starts iterating it. An iteration of a variable means, first setting it called and stable, then evaluating its \ac{rhs} and updating its value if necessary and lastly setting it to uncalled again. If during the evaluation of the \ac{rhs} of a variable $x$, a value from another variable $y$ is queried that is neither called nor stable, the iteration of $x$ is paused and $y$ is iterated until a stable value is found for it. If $y$ is called or stable, the query just returns its current value which is then used in the \ac{rhs} evaluation of $x$. Furthermore, for such a query it is tracked that $y$ influences $x$. This results in the solver recursively following the \textit{query} edges of the constraint graph until the solver reaches a variable, whose \ac{rhs} does not query any other variable, or a variable already marked as \textit{called}. Only then does it start iterating the current variable.
  To make the solver work, it is necessary to destabilize, if the value of a variable was changed during an iteration. This is done by setting all variables whose value is directly or indirectly influenced by this variable to \textit{not stable}. This is done, because these variables have to be iterated again, since their \ac{rhs} might change as it queries the changed variable.
  If the solver encounters a \textit{called} variable while exploring the \textit{query} edges, this variable is marked as a wpoint. This happens for program loops, since the variable at the loop head queries the last variable inside the loop next to the one before the loop. A variable being a wpoint means, that when this variable has to be updated during an iteration, i.e., the value from the \ac{rhs} is not equal to the current value, widening is applied. This means that the current value is not joined with the new one, but widened by it, which ensures termination of the solver. 
  Lastly we note that side-effects are computed as soon as they are encountered during the evaluation of an \ac{rhs}. If a variable receiving a side-effect has to be updated, all variables influenced by it are destabilized in the same manner as described above.
  % TODO: solver pseudo code?