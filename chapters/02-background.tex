\section{Background}
\label{sec:background}
To reason about the properties of a program, \gob\ computes abstract states for points between the instructions of the program. These abstract states describe all possible concrete states, the program could have at this point. With this mapping from program points to abstract states, properties like the existence or absence of data-race conditions in multithreaded programs can be deduced.\\
In detail, \gob\ analyzes programs in the following steps: First, the program is parsed and the corresponding control-flow graph (CFG) is generated. The nodes of the CFG are program-points, while its edges are labeled with the instructions that describe the transition from one point to another. From this CFG together with the specifications of the analyses to be performed, \gob\ builds a system of constraints, where the variables are program-points and the values abstract states. This system is solved with a fix-point solver for a mapping, from which the output is produced.

  \subsection{Side-effecting constraint systems}
  \label{sec:background:constrSys}
  A constraint system defines a function for each variable that describes how its value is calculated from the values of the other variables. We refer to this function as the ``right-hand side (\texttt{rhs})'' of a variable. This \texttt{rhs} can not only \textit{query} the values of other variables for calculation, but it can also trigger \textit{side-effects} to other variables. When a side-effect is triggered, it posts a value to another variable in the constraint system, i.e., the variable that receives the side-effect then has to map to a state representing its old value as well as the one received.\\
  In \gob\ it is ensured, that all variables receiving side-effects only have a trivial \texttt{rhs}, i.e., one that is only an initial value.

  \subsection{Top-down solver}
  \label{sec:background:td}
  TODO: introduce top down solver here (td\_simplified)
