\section{Background}
\label{sec:background}
%TODO: cite Gob homepage?
\gob\ is a static analyzer for C programs for detecting bugs and errors but also showing correctness. To prove certain properties about the program to be analyzed, it computes abstract states for each program point. These states describe all possible concrete state, the program can be in at that point in a sound manner. \gob\ finds the abstract states by solving a constraint system over the program points. This constraint system is generated from the \ac{cfg} according to the specifications of the type of analysis to be performed. The solution of the constraint system is a mapping from program points to abstract states, from which properties about bugs, errors and correctness can be deduced. \gob\ uses a fix-point solver to compute a satisfying solution.

  \subsection{Side-effecting constraint systems}
  \label{sec:background:constrSys}
  In this section we describe the constraint systems as they are generated and solved in \gob\ in more detail. The variables of the constraint system correspond to program points of the \ac{cfg}. If the program is analyzed context sensitively, each variable additionally has a context from an arbitrary set of contexts and thus, multiple variables can exist for the same program point with different contexts. This allows to analyze function calls from different calling contexts separately for increased precision. However, the additional context potentially makes the space of variables for the constraint system infinitely large as the context domain might be infinite. Even though this sounds bad at first, since a non-trivial solution to an infinite constraint system cannot be computed in finite time, this is not an issue. In the case of program analysis, the solution to the constraint system does not have to include a satisfying mapping to all variables, but only to those reachable from a set of one or more \textit{interesting} variables. In the case of program analysis in \gob\ this is usually the variable corresponding to the program point at the end of the main function.
  The value domain of the constraint system is a space of abstract states, that varies according to the specification of the analysis to be performed. In any case it has to be a complete lattice with a well-defined partial order, meet and join operations as well as a largest (top) and a least (bottom) value. Furthermore, to ensure termination of the constraint solver, widen and narrow operations are required.
  The constraint system now defines a constraint function for each variable. We refer to this function as the ``\ac{rhs}'' of a variable. The constraint system requires the variable to hold a value that is greater or equal to the value computed by the \ac{rhs} with respect to the partial order of the value lattice.
  The \ac{rhs} of a function can depend on other variables in the constraint system. We say, it \textit{queries} another variable for its value and uses that for its calculations.
  A peculiarity of the \gob\ analyzer is that it uses \textit{side-effecting} constraint systems. This means that some \ac{rhs} trigger \textit{side-effects} to other variables. When a side-effect is triggered, it posts a value to another variable in the constraint system, i.e., the variable that receives the side-effect has to hold a value, that is greater or equal to its previous value and the value received through the side effect. In \gob\ this is for example used for function calls to post the state from the caller to the variable at the start of the called function.
  For \gob\ it is ensured, that all variables that receive side-effects only have a trivial \ac{rhs}, i.e., one that is only a constant initial value.
  We can think of the constraint system as a graph, where the program points are the nodes and the edges represent queries and side-effects from the \ac{rhs}, i.e., if the \ac{rhs} of variable $x$ queries variable $y$, we draw a \texttt{query} edge from $x$ to $y$. Similarly, a side-effect from $x$ to $y$ results in an \texttt{side-effect} edge from $x$ to $y$. The \texttt{query} edges span a graph very similar to the \ac{cfg} with flipped edges, since the \ac{rhs} for a variable usually queries the variable corresponding to the program point before it and applies the abstract effect of the instruction between the two program points to the queried value.
  We note here, that certain \acp{rhs} in \gob\ query a variable but discard the result, i.e., the value from the queried value is not used in the calculation of this \ac{rhs}. This is done to force that a satisfying solution for this and all variables it depends on has to be calculated. Furthermore, this forces side-effects from the \acp{rhs} of these variables to be triggered at some point. Concretely, queries whose results are discarded are used in the constraints for thread-creations. When a thread is created at the \ac{cfg} edge from variable $x$ to $y$, the \ac{rhs} of $y$ queries not only $x$ but also the return-variable of the created thread. The value of this return-variable is not used to compute the \ac{rhs}-value of $y$, but it forces the computation of a satisfying solution for the variables corresponding to the thread.
  We can define a sub-system of the constraint system originating at the return-variable of the created thread. Besides the return variable, the sub-system of the thread contains all variables that are queried directly or indirectly in the \ac{rhs} evaluation of the return-variable. In general, this sub-system is disjunct from the rest of the constraint-system with respect to \texttt{query} edges. However, there is a special case if a function is called from a created thread and another location in the program. If additionally the contexts of these calls are identical, two or more sub-systems can overlap in the variables of the function call with the same context. In the case of context-insensitive analysis, the contexts are always identical. Note that in any case side-effects happen across sub-systems.


  \subsection{Top-down solver}
  \label{sec:background:td}
  % TODO: cite "three improvements to top down solver" ?
  % TODO: somehow integrate notion of poi variables earlier
  \gob\ mainly employs \acp{td} to solve its constraint systems. The most optimized of these implements many improvements and additional features, including but not limited to solving with widening and narrowing phases and incremental analysis. 
  In this section we introduce a simplified version of this solver that is the basis for the parallelized solvers we introduce in~\autoref{sec:method:td_parallel}.
  The task of the solver is to compute a solution to the constraint system. Since the domain of the constraints is a complete lattice, this can be achieved through fix-point iteration. This means that all variables are assigned the bottom value of the lattice, after which the variables are repeatedly \textit{iterated} until a fix-point is reached. In each iteration of a variable, its \ac{rhs} is evaluated for a new value. If the new value is not the same as their current one, the variable is assigned a value greater than or equal to both the current and the new value. Once all variables have a that is at least as great as their \ac{rhs}, a fix-point is reached.
  Different solvers employ different strategies to decide which variable should be iterated next. Before explaining the strategy of the \ac{td} we introduce some important properties the solver tracks for the constraint variables:
  \begin{itemize}[leftmargin=*]
    \item \textbf{value:} The current value assigned to this variable from the value domain
    \item \textbf{called:} A called variable is currently in the stack of variables to be iterated.
    \item \textbf{stable:} A stable variable currently satisfies its constraints. This holds as long as none of the variables it depends on change their value.
    \item \textbf{influences:} A transitive relation between two variables $x$ and $y$. ``$x$ influences $y$'' means that the value of variable $y$ depends on the value of $x$, because the \ac{rhs} of $y$ queries $x$.
    \item \textbf{wpoint:} If a variable is updated while it is a widening-point (wpoint), widening is applied when computing the new value. This is necessary to ensure termination of the solver.
  \end{itemize}
  The \ac{td} starts from one variable form the set of interesting variables, for which it is supposed to compute a value and starts iterating it. An iteration of a variable means, first setting it called and stable, then evaluating its \ac{rhs} and updating its value if necessary and lastly removing it from the set of called variables. If during the evaluation of the \ac{rhs} of a variable $x$, a value from another variable $y$ is queried that is neither called nor stable, the iteration of $x$ is paused and $y$ is iterated until a stable value is found for it. If $y$ is called or stable, the query just returns its current value which is then used in the \ac{rhs} evaluation of $x$. Furthermore, for such a query it is tracked that $y$ influences $x$. This results in the solver recursively following the \textit{query} edges of the constraint graph until the solver reaches a variable, whose \ac{rhs} does not query any other variable, or a variable already marked as \textit{called}. Only then does it start iterating the current variable.
  To make the solver work, it is necessary to destabilize, if the value of a variable was changed during an iteration. This is done by recursively following the influences-relation of the updated variable and setting all encountered variables to \textit{not stable} while removing the used paths from the influences-relation to avoid infinite loops during destabilization. Destabilizing is necessary because the influenced variables have to be iterated again, since their \ac{rhs} might change as it queries the changed variable.
  If the solver encounters a \textit{called} variable while exploring the \texttt{query} edges, this variable is marked as a wpoint. This happens for program loops, since the variable at the loop head queries the last variable inside the loop next to the one before the loop. A variable being a wpoint means, that when this variable has to be updated during an iteration, i.e., the value from the \ac{rhs} is not equal to the current value, widening is applied. This means that the current value is not joined with the new one, but widened by it, which ensures termination of the solver. 
  Lastly, we note that side-effects are computed as soon as they are encountered during the evaluation of an \ac{rhs}. If a variable receiving a side-effect has to be updated, all variables influenced by it are destabilized in the same manner as described above.
  % TODO: solver pseudo code?