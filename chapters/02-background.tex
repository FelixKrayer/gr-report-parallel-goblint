\section{Background}
\label{sec:background}
%TODO: cite Gob homepage?
\gob\ is a static analyzer for C programs for detecting bugs and errors but also showing correctness. To prove certain properties about the program to be analyzed, it computes abstract states for each program point. These states describe all possible concrete state, the program can be in at that point in a sound manner. \gob\ finds the abstract states by solving a constraint system over the program points. This constraint system is generated from the control-flow graph according to the specifications of the type of analysis to be performed. The solution of the constraint system is a mapping from program points to abstract states, from which properties about bugs, errors and correctness can be deduced. \gob\ uses a fix-point solver to compute a satisfying solution.

  \subsection{Side-effecting constraint systems}
  \label{sec:background:constrSys}
  In this section we describe the constraint systems as they are generated and solved in \gob\ in more detail. The variables of the constraint system are pairs of one program point and the corresponding calling context to allow the analysis of function calls in different contexts. However, for simplicity we think of the variables being just program points without context in this report. %TODO: maybe remove or reword
  The value domain of the constraint system is a space of abstract states, that varies according to the specification of the analysis to be performed. In any case it has to be a complete lattice with a well-defined partial order, meet and join operations as well as a largest (top) and a least (bottom) value. Furthermore, to ensure termination of the constraint solver, widen and narrow operations are required.
  The constraint system now defines a constraint function for each variable. We refer to this function as the ``right-hand side (\texttt{rhs})'' of a variable. The constraint system requires the variable to hold a value that is greater or equal to the value computed by the \texttt{rhs} with respect to the partial order of the value lattice.
  The \texttt{rhs} of a function can depend on other variables in the constraint system. We say, it \textit{queries} another variable for its value and uses that for its calculations.
  A peculiarity of the \gob\ analyzer is that it uses \textit{side-effecting} constraint systems. This means that some \texttt{rhs} trigger \textit{side-effects} to other variables. When a side-effect is triggered, it posts a value to another variable in the constraint system, i.e., the variable that receives the side-effect has to hold a value, that is greater or equal to its previous value and the value received through the side effect. In \gob\ this is for example used for function calls to post the state from the caller to the variable at the start of the called function.
  For \gob\ it is ensured, that all variables that receive side-effects only have a trivial \texttt{rhs}, i.e., one that is only a constant initial value.
  % Leave out?
  We can think of the constraint system as a graph, where the program points are the nodes and the edges represent queries and side-effects from the \texttt{rhs}, i.e., if the \texttt{rhs} of variable $x$ queries variable $y$, we draw a \textit{query} edge from $x$ to $y$. Similarly a side-effect from $x$ to $y$ results in an \textit{side-effect} edge from $x$ to $y$. The \textit{query} edges span a graph very similar to the control-flow graph with flipped edges, since the \texttt{rhs} for a variable usually queries the variable corresponding to the program point before it and applies the abstract effect of the instruction between the two program points to the queried value.

  \subsection{Top-down solver}
  \label{sec:background:td}
  % TODO: cite "three improvements to top down solver" ?
  % TODO: somehow integrate notion of poi variables earlier
  \gob\ mainly employs top-down solvers to solve its constraint systems. The most optimized of these uses implements many improvements and additional features, including but not limited to solving with widening and narrowing phases and incremental analysis. 
  In this section we introduce a simplified version of this solver that is the basis for the parallelized solvers we introduce in~\autoref{sec:method:td_parallel}.
  The task of the solver is to compute a solution to the constraint system. Since the domain of the constraints is a complete lattice, this can be achieved through fix-point iteration. This means that all variables are assigned the bottom value of the lattice, after which the variables are repeatedly \textit{iterated} until a fix-point is reached. This means that their \texttt{rhs} is evaluated for a new value. If the new value is not the same as their current one, the variable is assigned a value greater than or equal to both the current and the new value. Once all variables have a that is at least as great as their \texttt{rhs}, a fix-point is reached.
  Different solvers employ different strategies to decide which variable should be iterated next. The top-down solver starts from one or more interesting variables, for which it is supposed to compute a value. For \gob\ this is usually the variable corresponding to the program point at the end of the main function. It then recursively follows the \textit{query} edges of the constraint graph and marking all queried variables as \textit{called}. Furthermore, for each \textit{query} edge from variable $x$ to $y$, the solver follows, it tracks, that the variable $x$ depends on the value of variable $x$. Once the solver reaches a variable, whose \texttt{rhs} does not query any other variable, or it encounters a variable already marked as \textit{called} it starts iterating. After a variable is iterated, it is marked as \textit{stable}. A \textit{stable} variable currently satisfies all constraints, as long as none of the variables it depends on change their value.  

  % TODO: solver pseudo code?
