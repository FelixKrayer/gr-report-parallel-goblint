\section{Background}
\label{sec:background}
%TODO: cite Gob homepage?
\gob\ is a static analyzer for C programs for detecting bugs and errors but also proving correctness. To prove certain properties about the program to be analyzed, it computes abstract states for each program point. These states describe all possible concrete state, the program can be in at that point in a sound manner. \gob\ finds the abstract states by solving a constraint system over the program points. This constraint system is generated from the control-flow graph according to the specifications of the type of analysis to be performed. The solution of the constraint system is a mapping from program points to abstract states, from which properties about bugs, errors and correctness can be deduced.

  \subsection{Side-effecting constraint systems}
  \label{sec:background:constrSys}
  In this section we describe the constraint systems as they are generated and solved in \gob\ in more detail. The variables of the constraint system are pairs of one program point and the corresponding calling context to allow the analysis of function calls in different contexts. However, for simplicity we think of the variables being just program points without context in this report.
  The value domain of the constraint system is a space of abstract states, that varies according to the specification of the analysis to be performed. In any case it has to be a complete lattice with a well-defined partial order, meet and join operations as well as top and bottom elements. Furthermore, to ensure termination of the constraint solver, widen and narrow operations are required.
  The constraint system now defines a constraint function for each variable. We refer to this function as the ``right-hand side (\texttt{rhs})'' of a variable. The constraint system requires the variable to hold a value that is greater or equal to the value computed by the \texttt{rhs} with respect to the partial order of the value lattice.
  The \texttt{rhs} of a function can depend on other variables in the constraint system. We say, it \textit{queries} another variable for its value and uses that for its calculations.
  A peculiarity of the \gob\ analyzer is that it uses \textit{side-effecting} constraint systems. This means that some \texttt{rhs} trigger \textit{side-effects} to other variables. When a side-effect is triggered, it posts a value to another variable in the constraint system, i.e., the variable that receives the side-effect has to hold a value, that is greater or equal to its previous value and the value received through the side effect. In \gob\ this is for example used for function calls to post the state from the caller to the variable at the start of the called function.
  For \gob\ it is ensured, that all variables that receive side-effects only have a trivial \texttt{rhs}, i.e., one that is only a constant initial value.
  % Leave out?
  We can think of the constraint system as a graph, where the program points are the nodes and the edges represent queries and side-effects from the \texttt{rhs}, i.e., if the \texttt{rhs} of variable $x$ queries variable $y$, we draw a \textit{query} edge from $x$ to $y$. Similarly a side-effect from $x$ to $y$ results in an \textit{side-effect} edge from $x$ to $y$. The \textit{query} edges span a graph very similar to the control-flow graph with flipped edges, since the \texttt{rhs} for a variable usually queries the variable corresponding to the program point before it and applies the abstract effect of the instruction between the two program points to the queried value.

  \subsection{Top-down solver}
  \label{sec:background:td}
  % TODO: cite "three improvements to top down solver" ?
  \gob\ mainly uses top-down solvers to solve its constraint systems. The most optimized of these uses implements many improvements and additional features, including but not limited to solving with widening and narrowing phases and incremental analysis. 
  In this section we introduce a simplified version of this solver that is the basis for the parallelized solvers we introduce in~\autoref{sec:method:td_parallel}.
