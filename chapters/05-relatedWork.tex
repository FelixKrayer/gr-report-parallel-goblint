\section{Related Work}
\label{sec:relatedWork}
In this section, we discuss a few approaches other researchers proposed to parallelize fix-point algorithms or static analysis in general.
Bla√ü and Philippsen~\cite{blass2019gpu} propose a fix-point algorithm, where a GPU is used to propagate predicates between \ac{cfg} nodes in parallel. Each node is assigned to one of the usually more than 1000 GPU threads. The nodes repeatedly query the states of their predecessors in the \ac{cfg} and use the result to update their own state. The algorithm does not prevent data races through synchronization but detects and repairs inconsistencies caused by races. A heuristic is used to decide when to return to the CPU and check if a fix-point has been reached. If not, the GPU continues to work on a solution. Though this approach is promising and achieves a good speedup, it requires dedicated hardware to run. Furthermore, the variables of the constraint system have to be known beforehand, making it hard to apply this algorithm to context-sensitive analysis as it is implemented in \gob.
Aiken et al.~\cite{aiken2007overview} present the Saturn program analysis system. Saturn is summary-based which means, that summaries of individual functions are computed. A caller then uses this summary of a function to compute the effect of a call. This approach, where functions are analyzed separately without factoring in a calling context is easily parallelizable, being only limited by the dependencies between functions. Aiken et al. use this fact to analyze functions in parallel with great efficiency. However, to analyze whole programs like \gob\ does, this approach is less suitable, as it requires knowledge of the call graph beforehand.
The approach by Van Es et al.~\cite{van2020parallel} focuses on parallelizing modular analyses. This is similar to the Saturn system, as the program is divided into modules independently of each other. These modules can be functions or threads. In contrast to the Saturn system, it uses a demand-driven top-down approach to decide which functions to analyze. Similar to our usage of the \texttt{create} edges, the algorithm by Van Es et al. generates a task to analyze a thread or a function. While the modules might only depend on each other through function calls, \gob\ deals with side-effects across function and thread boundaries, which we had to take into account for our parallelization approaches.
