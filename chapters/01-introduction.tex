\section{Introduction}
\label{sec:introduction}
% Copied and slightly adapted from project description.
Static analyzers examine the source code of a program to find semantic properties without having to execute it. To gain information about a program, many analyzers ---in particular abstract-interpreters--- compute abstract values for the different program points that over-approximate the set of possible concrete states. This is done by generating a system of constraints, where the variables are program points, possibly together with some calling context. The instructions in the code give rise to constraints describing how they affect the abstract state. When the system of constraints is generated, the analyzer computes a solution through fix-point iteration. This means that from an initial non-satisfying assignment of values to variables, these values are updated according to the constraints until a fix-point is reached, and all constraints are satisfied. Well-known algorithms for fix-point iteration are round-robin iteration and the work-list algorithm. Round-robin algorithms can, however, only be used for finite constraint systems and the work-list algorithm usually requires static dependencies. In contrast, the top-down solver recursively explores a possibly infinite constraint system on demand and tracks dynamic dependencies on the fly. It aims to find solutions for a defined set of interesting variables, e.g., the end node of the main program. For that, it recursively computes stable values for variables that are needed to calculate the values for the set of interesting ones. If the value for a stable variable is needed, it can just be looked up and does not have to be calculated again. However, if a new value for a variable is computed and updated during the solving process, it is necessary to destabilize all variables that depend on this updated variable. This means that the values for the now destabilized variables have to be evaluated again as they have to factor in the new value of the updated variable. These dependencies of variables are detected dynamically during the solving process and are saved in a data structure. Further data structures are used to keep track of stable variables and their values. 
The time of analysis grows together with program size. For example, an analysis of SQL lite 3 takes multiple hours with the \gob\ static analyzer. Calculating a solution for the constraint system takes up a significant part of the overall analysis time. Thus, improving the performance of a solver with respect to computation time seems a promising way to improve the speed of the whole analysis. An idea to approach this issue is to equip the top-down solver with a way to execute tasks in parallel and find steps of the solving process, where a speedup can likely be achieved through parallelization. For example, a variable can depend on multiple other variables, e.g., when a thread is created and the thread function has to be analyzed as well as the rest of the program. In this case, one can imagine, that stable values for the variables corresponding to the thread function could be computed parallel to the variables corresponding to the main program, and the computation time could be reduced.
As our main contribution, we aim to implement a parallelized top-down solver for the \gob\ analyzer.\\
This report is structured as follows: In~\autoref{sec:background} we introduce side-effecting constraint systems as they are used in \gob\ and explain how a single-threaded top-down solver works. In~\autoref{sec:method} we present our contributions. We explain how we adapt the constraint system to indicate for which variables parallelized solving can be useful. Furthermore, we implement a thread-safe data structure in this section. In~\autoref{sec:method:td_parallel} we present three different concepts of parallelized solvers and implement them in \gob\ as our main contribution. We evaluate our implementation by comparing the runtimes of the solvers in~\autoref{sec:eval}. Lastly we give our conclusions and ideas for future work in~\autoref{sec:conclusions} 
